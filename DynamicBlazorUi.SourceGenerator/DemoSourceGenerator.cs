using System.Collections.Immutable;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace DynamicBlazorUi.SourceGenerator;

[Generator]
public class DemoSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var enumTypes = context.SyntaxProvider
            .CreateSyntaxProvider(CouldBeEnumerationAsync, GetEnumTypeOrNull)
            .Where(type => type is not null)
            .Collect();


        context.RegisterSourceOutput(enumTypes, GenerateCode);
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<MyRet> enumerations)
    {
        if (enumerations.IsDefaultOrEmpty)
            return;

        foreach (var type in enumerations)
        {
            var code = GenerateCode(type);
            // var typeNamespace = type.ContainingNamespace.IsGlobalNamespace
            //     ? null
            //     : $"{type.ContainingNamespace}.";

            context.AddSource($"{type.Namespace}{type.Name}.g.cs", code);
        }
    }

    private static string GenerateCode(MyRet type)
    {
        var ret = $@"// <auto-generated />

using System.Collections.Generic;
using DynamicBlazor.Services;
using Microsoft.AspNetCore.Components;
using TestingModule.Services;

namespace {type.Namespace}
{{
   partial class {type.ClassName} : ComponentBase
   {{
        [Inject] private IRemoteDependencyResolver RemoteDependencyResolver {{ get; set; }}

        protected override async Task OnInitializedAsync()
        {{
            await base.OnInitializedAsync();
            {type.Name} = RemoteDependencyResolver.Resolve<{type.ServiceName.Trim()}>();
        }}
   }}
}}
";
        return ret;
    }

    private static IEnumerable<string?> GetItemNames(ITypeSymbol type)
    {
        return type.GetMembers()
            .Select(m =>
            {
                if (!m.IsStatic ||
                    m.DeclaredAccessibility != Accessibility.Public ||
                    m is not IFieldSymbol field)
                    return null;

                return SymbolEqualityComparer.Default.Equals(field.Type, type)
                    ? field.Name
                    : null;
            })
            .Where(field => field is not null);
    }

    private static bool CouldBeEnumerationAsync(
        SyntaxNode syntaxNode,
        CancellationToken cancellationToken)
    {
        if (syntaxNode is not AttributeSyntax attribute)
            return false;

        var name = ExtractName(attribute.Name);

        return name is "InjectModuleService" or "InjectModuleServiceAttribute";
    }

    private static string? ExtractName(NameSyntax? name)
    {
        return name switch
        {
            SimpleNameSyntax ins => ins.Identifier.Text,
            QualifiedNameSyntax qns => qns.Right.Identifier.Text,
            _ => null
        };
    }

    private static MyRet? GetEnumTypeOrNull(
        GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var attributeSyntax = (AttributeSyntax) context.Node;

        // "attribute.Parent" is "AttributeListSyntax"
        // "attribute.Parent.Parent" is a C# fragment the attributes are applied to
        if (attributeSyntax.Parent?.Parent is not FieldDeclarationSyntax fieldDeclarationSyntax)
            return null;

        var goose = context.Node.Parent.Parent;
        var type = context.SemanticModel.GetDeclaredSymbol(fieldDeclarationSyntax) as ITypeSymbol;
        var name = fieldDeclarationSyntax.Declaration.Type.GetText();
        var shouldContinue = context.Node.ToString() is "InjectModuleService" or "InjectModuleService";
        if (!shouldContinue)
        {
            return null;
        }

        var res = new MyRet()
        {
            ServiceName = fieldDeclarationSyntax.Declaration.Type.GetText().ToString(),
            Namespace = context.SemanticModel.LookupNamespacesAndTypes(0).First().ToString(),
            Name = fieldDeclarationSyntax.Declaration.Variables[0].ToString(),
            ClassName = context.SemanticModel.GetDeclaredSymbol(context.Node.Parent.Parent!.Parent!)!.Name
        };
        return res;
    }
}

class MyRet
{
    public string Namespace { get; set; }
    public string Name { get; set; }
    public string ServiceName { get; set; }
    public string ClassName { get; set; }
}